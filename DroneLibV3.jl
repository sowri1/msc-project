# import Pkg;
# Pkg.add("CUDA")
# Pkg.add("cuDNN")
# Pkg.add("CompilerPluginTools")
# Pkg.add("PlotlyJS")
# Pkg.add("DifferentialEquations")
# Pkg.add("Plots")
# Pkg.add("Flux")
# Pkg.add("JLD2")
# Pkg.add("BSON")
# Pkg.add("Distributions")
# Pkg.instantiate()

# using DifferentialEquations
using LinearAlgebra
using Distributions
using Plots
using Random
using Random
using Flux
using Flux.Optimise: update!
using CUDA
using BSON
using Base.Threads
import Base: rand
using BSON: @load, @save

### Drone Paremeters
mass = 1.0
mass_arm = 0.050
mass_motor = 0.025
arm_length = 0.15

force_per_rpm = 4e-8 # force generated by each propeller per rpm, N/(rpm^2)
torque_per_rpm = arm_length * 1e-9 # torque generated by each propeller per rpm, Nm/(rpm^2)

I_arm = 1/3 * mass_arm * arm_length^2
I_motor = 1/2 * mass_motor * arm_length^2
Ixx = 2 * I_arm + 2 * I_motor
Iyy = 2 * I_arm + 2 * I_motor
Izz = 4 * I_arm + 4 * I_motor

gravity = 9.81 # gravitational constant, m/s^2
frequency = 1000 # frequency of the simulation, Hz

BOUND_MAX = 10.0

mutable struct Drone
	position::Array{Float64,1}
	velocity::Array{Float64,1}
	acceleration::Array{Float64,1}
	orientation::Array{Float64,1} # roll, pitch, yaw in radians
	angular_velocity::Array{Float64,1}
	angular_acceleration::Array{Float64,1}
end

mutable struct DroneEnv
	drone::Drone
	target_position::Array{Float64,1}
	previous_position::Array{Float64,1}
	action::Array{Float64,1}
	reward::Float64
	done::Bool

	bound_x::Float64
	bound_y::Float64
	bound_z::Float64

	time::Float64
	max_time::Float64
end

function DroneEnv()
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	target_position = [10.0, 10.0, 10.0]
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1})
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1}, max_time::Float64)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, max_time)
end

function reset!(env::DroneEnv)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), zeros(3), zeros(3))
	env.action = zeros(4)
	env.previous_position = zeros(3)
	env.done = false
	env.reward = 0.0
	env.time = 0.0
	env.drone = drone
end

function RewardFunction(env::DroneEnv)
	# Get the current state of the environment
	orientation = env.drone.orientation

	# Calculate the distance to the target
	dist_to_target = norm(env.target_position - env.drone.position)

	# Calculate the distance to the target in the previous step
	prev_dist_to_target = norm(env.previous_position - env.target_position)

	# Calculate the velocity towards the target
	vel_towards_target = dot(env.drone.velocity, env.target_position - env.drone.position)

	# Calculate the angle between the drone's heading and the direction to the target
	# facing_dir = [cos(orientation[3]), sin(orientation[3])]
	# drone_dir = [cos(orientation[1]) * cos(orientation[2]), sin(orientation[1]) * cos(orientation[2])]
	# angle_to_target = acos(dot(facing_dir, drone_dir))

	velocity_magnitude = norm(env.drone.velocity)
	angular_vel_magnitude = norm(env.drone.angular_velocity)

	reward = 0.0

	# reward -= sum([
	# 	(env.action[i] - env.action[j])^2
	# 	for i in 1:4
	# 	for j in i:4
	# 	if i != j
	# ])

	# if dist_to_target < prev_dist_to_target
	# 	reward += 5
	# else
	# 	reward -= 5
	# end

	# println("dist_to_target: ", dist_to_target, " prev_dist_to_target: ", prev_dist_to_target, " reward: ", reward)
	# reward -= 5e0 * abs(env.target_position[1] - env.drone.position[1]) / BOUND_MAX
	# reward -= 5e0 * abs(env.target_position[2] - env.drone.position[2]) / BOUND_MAX
	reward -= 1e1 * abs(env.target_position[3] - env.drone.position[3]) / BOUND_MAX

	# reward -= 5e1 * dist_to_target / BOUND_MAX

	if env.target_position[3] > 0.5
		reward += 5
	end

	# println("target_position: ", env.target_position, " drone_position: ", env.drone.position, " reward: ", reward)

	if dist_to_target < 0.5
		reward += 10
	end

	# println("dist_to_target: ", dist_to_target, " reward: ", reward)

	# reward -= 2 * velocity_magnitude * (velocity_magnitude > 5)
	reward -= angular_vel_magnitude
	reward -= norm(orientation)

	# println("velocity_magnitude: ", velocity_magnitude, " angular_vel_magnitude: ", angular_vel_magnitude, " reward: ", reward)

	if env.done
		if dist_to_target < 0.1
			reward += 100
		else
			reward -= 100
		end
	end

	# println("reward: ", reward)

	return reward
end

function is_terminated(env::DroneEnv, verbose::Bool=false)

	# Check the bounds of the drone
	if abs(env.drone.position[1]) > env.bound_x || abs(env.drone.position[2]) > env.bound_y || env.drone.position[3] < 0.0 || env.drone.position[3] > env.bound_z
		if verbose
			println("drone out of bounds")
		end
		env.done = true
	end

	# Check if the drone is crashed
	if env.drone.position[3] < 1e-5 && (abs(env.drone.orientation[1]) >= 0.99*pi || abs(env.drone.orientation[2]) >= 0.99*pi)
		if verbose
			println("drone crashed")
		end
		env.done = true
	end

	if norm([env.drone.position[1] - env.target_position[1]; env.drone.position[2] - env.target_position[2]; env.drone.position[3] - env.target_position[3]]) < 0.01
		if verbose
			println("drone reached target")
		end
		env.done = true
	end

	if env.time > env.max_time
		if verbose
			println("time limit reached")
		end
		env.done = true
	end

	return env.done
end

function get_angle_mod_2pi(angle)
	return atan(sin(angle), cos(angle))
end

function NonLinearDroneDynamics!(x::CuArray{Float32}, rpms, t)
	CUDA.allowscalar() do
		U = [
			force_per_rpm * (rpms[1]^2 + rpms[2]^2 + rpms[3]^2 + rpms[4]^2);
			force_per_rpm * (-rpms[1]^2 - rpms[2]^2 + rpms[3]^2 + rpms[4]^2);
			force_per_rpm * (-rpms[1]^2 + rpms[2]^2 + rpms[3]^2 - rpms[4]^2);
			torque_per_rpm * (-rpms[1]^2 + rpms[2]^2 - rpms[3]^2 + rpms[4]^2);
			-rpms[1] + rpms[2] - rpms[3] + rpms[4];
		] 

		u = [
			(sin(x[10]) * cos(x[12])) - (cos(x[10]) * sin(x[11]) * sin(x[12]));
			(cos(x[10]) * sin(x[11]) * cos(x[12])) + (sin(x[10]) * sin(x[12]));
			cos(x[10]) * cos(x[11]);
		]

		### Calculate the derivative of the state vector
		du = [
			x[1] + x[4]*t;
			x[2] + x[5]*t;
			x[3] + x[6]*t;
			
			x[4] + (x[7] * t);
			x[5] + (x[8] * t);
			x[6] + (x[9] * t);

			(u[1] * U[1] / mass);
			(u[2] * U[1] / mass);
			((u[3] * U[1] / mass) - gravity);

			get_angle_mod_2pi(x[10] + (x[13]*t));
			get_angle_mod_2pi(x[11] + (x[14]*t));
			get_angle_mod_2pi(x[12] + (x[15]*t));

			x[13] + (x[16] * t);
			x[14] + (x[17] * t);
			x[15] + (x[18] * t);

			(((Iyy - Izz) * x[11] * x[12]) + (U[2] * arm_length)) / Ixx;
			(((Izz - Ixx) * x[10] * x[12]) + (U[3] * arm_length)) / Iyy;
			(((Ixx - Iyy) * x[10] * x[11]) + (U[4])) / Izz;
		]

		### Handle the case when the drone is on the ground and not enough thrust is applied to take off
		if du[3] <= 0.0
			du[3] = 0.0
			if du[6] < 0.0
				du[6] = 0.0
			end
		end
		return du
	end
end

function get_state(drone::Drone)
	return [drone.position...; drone.velocity...; drone.acceleration; drone.orientation...; drone.angular_velocity...; drone.angular_acceleration] |> gpu
end

function step!(env::DroneEnv, action::CuArray{Float64, 1}, verbose::Bool=false)
	tspan = 1 / frequency
	du = zeros(25)
	env.previous_position = env.drone.position
	env.action = action ./ MAX_ACTION
	du = NonLinearDroneDynamics!(get_state(env.drone), action, tspan)
	env.drone.position = du[1:3]
	env.drone.velocity = du[4:6]
	env.drone.acceleration = du[7:9]
	env.drone.orientation = du[10:12]
	env.drone.angular_velocity = du[13:15]
	env.drone.angular_acceleration = du[16:18]
	env.done = is_terminated(env, verbose)
	env.reward = RewardFunction(env)
	env.time += tspan
	return env.reward, env.done
end

function plotStateSpaces(state_spaces, dpi=100, save_fig=false, ouptut_dir="results", suffix="", angular_velocity_moving_average = 8)

	trajectory_x = []
	trajectory_y = []
	trajectory_z = []

	velocity_x = []
	velocity_y = []
	velocity_z = []

	orientation_x = []
	orientation_y = []
	orientation_z = []

	angular_velocity_x = []
	angular_velocity_y = []
	angular_velocity_z = []

	for state in state_spaces
		push!(trajectory_x, state[1])
		push!(trajectory_y, state[2])
		push!(trajectory_z, state[3])

		push!(velocity_x, state[4])
		push!(velocity_y, state[5])
		push!(velocity_z, state[6])

		push!(orientation_x, state[10])
		push!(orientation_y, state[11])
		push!(orientation_z, state[12])

		push!(angular_velocity_x, state[13])
		push!(angular_velocity_y, state[14])
		push!(angular_velocity_z, state[15])

	end

	# angular_velocity_x = [mean(angular_velocity_x[i:i+angular_velocity_moving_average-1]) for i in 1:length(angular_velocity_x)-angular_velocity_moving_average+1]
	# angular_velocity_y = [mean(angular_velocity_y[i:i+angular_velocity_moving_average-1]) for i in 1:length(angular_velocity_y)-angular_velocity_moving_average+1]
	# angular_velocity_z = [mean(angular_velocity_z[i:i+angular_velocity_moving_average-1]) for i in 1:length(angular_velocity_z)-angular_velocity_moving_average+1]

	image_size = (800, 600)
	### Plot the drone's position
	display(plot([trajectory_x, trajectory_y, trajectory_z], legend=:topleft, label=["x" "y" "z"], title="Trajectory", xlabel="Time (ms)", ylabel="Position (m)", lw=2, size=image_size, grid=true, dpi=dpi))
	# save the plot to a file
	if save_fig
		savefig("$ouptut_dir/trajectory_$suffix.png")
	end

	# ### Plot the drones velocity
	display(plot([velocity_x, velocity_y, velocity_z], legend=:topleft, label=["x" "y" "z"], title="Velocity", xlabel="Time (ms)", ylabel="Velocity (m/s)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/velocity_$suffix.png")
	end

	# ### Plot the drones orientation
	display(plot([orientation_x, orientation_y, orientation_z], legend=:topleft, label=["x" "y" "z"], title="Orientation", xlabel="Time (ms)", ylabel="Orientation (rad)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/orientation_$suffix.png")
	end

	# ### Plot the drones angular velocity
	display(plot([angular_velocity_x, angular_velocity_y, angular_velocity_z], legend=:topleft, label=["x" "y" "z"], title="Angular Velocity", xlabel="Time (ms)", ylabel="Angular Velocity (rad/s)", lw=2, size = image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/angular_velocity_$suffix.png")
	end
end

function plotMotorRpms(motor_rpms, dpi=100, save_fig=false, ouptut_dir="results", suffix="", moving_average=6)
	motor1_rpms = []
	motor2_rpms = []
	motor3_rpms = []
	motor4_rpms = []

	for rpm in motor_rpms
		push!(motor1_rpms, rpm[1])
		push!(motor2_rpms, rpm[2])
		push!(motor3_rpms, rpm[3])
		push!(motor4_rpms, rpm[4])
	end

	# motor1_rpms = [mean(motor1_rpms[i:i+moving_average-1]) for i in 1:length(motor1_rpms)-moving_average+1]
	# motor2_rpms = [mean(motor2_rpms[i:i+moving_average-1]) for i in 1:length(motor2_rpms)-moving_average+1]
	# motor3_rpms = [mean(motor3_rpms[i:i+moving_average-1]) for i in 1:length(motor3_rpms)-moving_average+1]
	# motor4_rpms = [mean(motor4_rpms[i:i+moving_average-1]) for i in 1:length(motor4_rpms)-moving_average+1]

	display(
		plot(
			[motor1_rpms, motor2_rpms, motor3_rpms, motor4_rpms],
			legend=:topleft,
			label=["Motor 1" "Motor 2" "Motor 3" "Motor 4"], 
			xlabel="Time (ms)", 
			ylabel="RPM", 
			title="RPM of motors", 
			lw=2,
			size=(800, 600), 
			grid=true,
			dpi=dpi
		)
	)
	if save_fig
		savefig("$ouptut_dir/motor_rpms_$suffix.png")
	end
end

function plot3DTrajectory(state_spaces, dpi=100, save_fig=false, ouptut_dir="results")
	trajectory_x = []
	trajectory_y = []
	trajectory_z = []

	for state in state_spaces
		push!(trajectory_x, state[1])
		push!(trajectory_y, state[2])
		push!(trajectory_z, state[3])
	end

	display(path3d(
		trajectory_x, 
		trajectory_y, 
		trajectory_z, 
		lw=2,
		title="3D Trajectory of the drone",
		size=(800, 600), 
		xlabel="X (m)", 
		ylabel="Y (m)", 
		zlabel="Z (m)", 
		label = false, 
		dpi=dpi
	))
	if save_fig
		savefig("$ouptut_dir/3d_trajectory.png")
	end
end