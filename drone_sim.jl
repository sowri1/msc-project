using DifferentialEquations
using Plots

# Define the drone's state
mutable struct Drone
    position::Array{Float64,1}
    velocity::Array{Float64,1}
    orientation::Array{Float64,1} # roll, pitch, yaw in radians
    angular_velocity::Array{Float64,1}
end

# Initialize a drone
drone = Drone([0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0])

# Define the drone's dynamics (e.g., movement equations)
function drone_dynamics!(du, u, p, t)
    gravity = 9.81 # gravitational constant, m/s^2
    mass = 1.0 # drone mass in kg
    force_per_rpm = 0.001 # placeholder: force generated by one propeller at 1 RPM
    distance_to_propellers = 0.5 # distance from the drone's center to each propeller

    rpms = p(t) # propeller speeds in RPM at time t
    forces = force_per_rpm .* rpms # forces generated by each propeller

    net_force = sum(forces) - mass*gravity # net force (upward force - weight)
    net_torque_pitch = (forces[1] + forces[4] - forces[2] - forces[3])*distance_to_propellers # net torque around x-axis
    net_torque_roll = (forces[1] + forces[2] - forces[3] - forces[4])*distance_to_propellers # net torque around y-axis
    net_torque_yaw = 0.0 # For simplicity, not considering changes in yaw. Implement if needed

    moment_of_inertia = mass * distance_to_propellers^2 # placeholder: moment of inertia around y-axis

    du[1:3] = u[4:6] # position updates with velocity
    du[4:6] = [0.0, 0.0, net_force/mass] # velocity updates with acceleration
    du[7:9] = u[10:12] # orientation updates with angular velocity
    du[10:12] = [net_torque_roll/moment_of_inertia, net_torque_pitch/moment_of_inertia, net_torque_yaw/moment_of_inertia] # angular velocity updates with angular acceleration
end


# Define function for changing propeller RPMs over time
function rpm_changes(t)
    base_rpm = 1500.0
    # For demonstration, make some simple periodic changes
    rpm1 = base_rpm + 500.0*sin(t)
    rpm2 = base_rpm + 500.0*sin(t + pi/2)
    rpm3 = base_rpm + 500.0*sin(t + pi)
    rpm4 = base_rpm + 500.0*sin(t + 3pi/2)
    return [rpm1, rpm2, rpm3, rpm4]
end


# Define the initial conditions for the simulation
u0 = [drone.position; drone.velocity; drone.orientation; drone.angular_velocity]
tspan = (0.0, 10.0)  # Simulate for 10 seconds
problem = ODEProblem(drone_dynamics!, u0, tspan, rpm_changes)
solution = solve(problem)

# Create an animation of the drone's trajectory
animation = @animate for i=1:length(solution.t)
    plot3d([u[1] for u in solution.u[1:i]], [u[2] for u in solution.u[1:i]], [u[3] for u in solution.u[1:i]], 
        xlabel="x", ylabel="y", zlabel="z", legend=false, title="Drone trajectory")
end

# Save the animation as a gif
gif(animation, "drone_trajectory.gif", fps = 15)