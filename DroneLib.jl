# import Pkg;
# Pkg.add("ReinforcementLearning")
# Pkg.add("ReinforcementLearningBase")
# Pkg.add("ReinforcementLearningCore")
# Pkg.add("CUDA")
# Pkg.add("CompilerPluginTools")
# Pkg.add("PlotlyJS")
# Pkg.add("DifferentialEquations")
# Pkg.add("Plots")
# Pkg.add("Flux")
# Pkg.add("Distributions")
# Pkg.instantiate()

# using DifferentialEquations
using Plots
# using ReinforcementLearningBase
# using ReinforcementLearningCore
using Random
using LinearAlgebra
# using Flux
using Distributions
# using Flux: params, gradient
using Base.Threads
import Base: rand

mass = 1.0
mass_arm = 0.050
mass_motor = 0.025
arm_length = 0.15

I_arm = 1/3 * mass_arm * arm_length^2
I_motor = 1/2 * mass_motor * arm_length^2
Ixx = 2 * I_arm + 2 * I_motor
Iyy = 2 * I_arm + 2 * I_motor
Izz = 4 * I_arm + 4 * I_motor

### Moment of inertia for 6 DOF drone in 3x3 matrix form with the variables substituted
moment_of_inertia = [ Ixx 0.0 0.0; 0.0 Iyy 0.0; 0.0 0.0 Izz]

force_per_rpm = 4e-8 # force generated by each propeller per rpm, N/(rpm^2)
torque_per_rpm = 1e-9 # torque generated by each propeller per rpm, Nm/(rpm^2)
gravity = 9.81 # gravitational constant, m/s^2
frequency = 100 # frequency of the simulation, Hz

struct ContinuousDroneActionSpace
	action_range::Tuple{Array{Float64}, Array{Float64}} # define action_range within the space struct
end

mutable struct ContinuousDroneStateSpace
	position_low::Array{Float64,1}
	position_high::Array{Float64,1}
	velocity_low::Array{Float64,1}
	velocity_high::Array{Float64,1}
	orientation_low::Array{Float64,1}
	orientation_high::Array{Float64,1}
	angular_velocity_low::Array{Float64,1}
	angular_velocity_high::Array{Float64,1}
end

# function rand(rng::AbstractRNG, space::ContinuousDroneActionSpace, num::Int)
# 	low, high = space.action_range
# 	return [rand(rng, low[i]:high[i]) for i in 1:length(low), _ in 1:num]
# end

# import Random

# function Random.Sampler(rng::Random.AbstractRNG, space::ContinuousDroneActionSpace, ::Random.Repetition)
# 	return space
# end

# function Random.rand(rng::Random.AbstractRNG, sampler::ContinuousDroneActionSpace)
# 	low, high = sampler.action_range
# 	return [rand(rng, low[i]:high[i]) for i in 1:length(low)]
# end

mutable struct Drone
	position::Array{Float64,1}
	velocity::Array{Float64,1}
	orientation::Array{Float64,1} # roll, pitch, yaw in radians
	angular_velocity::Array{Float64,1}

	mass::Float64
	force_per_rpm::Float64
	arm_length::Float64
	moment_of_inertia::Array{Float64,2}
end

mutable struct DroneEnv
	drone::Drone
	target_position::Array{Float64,1}
	previous_position::Array{Float64,1}
	action::Array{Float64,1}
	reward::Float64
	done::Bool

	velocity_threshold::Float64
	alititude_threshold::Float64
	angular_velocity_threshold::Float64
	roll_threshold::Float64
	pitch_threshold::Float64

	time::Float64
	max_time::Float64
end

function DroneEnv()
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), mass, force_per_rpm, arm_length, moment_of_inertia)
	action = zeros(4)
	target_position = [10.0, 10.0, 10.0]
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, 10, 10, 5, pi/4, pi/4, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1})
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), mass, force_per_rpm, arm_length, moment_of_inertia)
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, 10, 10, 5, pi/4, pi/4, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1}, max_time::Float64)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), mass, force_per_rpm, arm_length, moment_of_inertia)
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, 10, 10, 5, pi/4, pi/4, 0, max_time)
end


### Define Action Space for quadcopter rpm of each motor
# action_space(env::DroneEnv) = ContinuousDroneActionSpace((zeros(4), ones(4)*20000))
# RLBase.state(env::DroneEnv) = [env.drone.position; env.drone.velocity; env.drone.orientation; env.drone.angular_velocity; env.drone.mass; env.drone.force_per_rpm; env.drone.arm_length; env.drone.moment_of_inertia]
# RLBase.is_terminated(env::DroneEnv) = env.done
# RLBase.state_space(env::DroneEnv) = ContinuousDroneStateSpace(
# 	[-100.0, -10.0, 0.0],
# 	[100.0, 100.0, 100.0], 
# 	[-10.0, -10.0, -10.0],
# 	[10.0, 10.0, 10.0],
# 	[-pi, -pi, -pi],
# 	[pi/1, pi/1, pi/1],
# 	[-pi, -pi, -pi],
# 	[pi/1, pi/1, pi/1],
# )
# RLBase.action_space(env::DroneEnv, action::Array{Float64,1}) = ContinuousDroneActionSpace(zeros(4), ones(4)*2000)

function reset!(env::DroneEnv)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3), mass, force_per_rpm, arm_length, moment_of_inertia)
	env.previous_position = zeros(3)
	env.done = false
	env.reward = 0.0
	env.time = 0.0
	env.drone = drone
end

# function RewardFunction(env::DroneEnv)
# 	tot_reward = 0.0
# 	prev_dist_to_target = norm(env.previous_position - env.target_position)
# 	dist_to_target = norm(env.drone.position - env.target_position)
# 	yaw = env.drone.orientation[3]
# 	roll = env.drone.orientation[1]
# 	pitch = env.drone.orientation[2]

# 	tot_reward -= dist_to_target

# 	if roll > pi/2 || roll < -pi/2 || pitch > pi/4 || pitch < -pi/4
# 		tot_reward -= 1000
# 	end

# 	facing_dir = [cos(yaw), sin(yaw)]
# 	drone_dir = [cos(roll)*cos(pitch), sin(roll)*cos(pitch)]
# 	if dot(facing_dir, drone_dir) < 0.0
# 		tot_reward -= 1000
# 	end

# 	if dot(env.drone.velocity, env.target_position - env.drone.position) < 0.0
# 		tot_reward -= 1000
# 	end
	
# 	if env.drone.angular_velocity[1] != 0.0 || env.drone.angular_velocity[2] != 0.0
# 		tot_reward -= abs(sum(env.drone.angular_velocity[1:2]))
# 	end

# 	if env.drone.angular_velocity[3] != 0.0
# 		tot_reward -= abs(env.drone.angular_velocity[3])
# 	end

# 	if dist_to_target < prev_dist_to_target
# 		tot_reward += 100
# 	end
# 	if dist_to_target < 0.1
# 		tot_reward += 1000
# 	end

# 	return tot_reward
# end

function RewardFunction(env::DroneEnv)
	# Get the current state of the environment
	position = env.drone.position
	previous_position = env.previous_position
	velocity = env.drone.velocity
	orientation = env.drone.orientation
	angular_velocity = env.drone.angular_velocity
	target_position = env.target_position

	# Calculate the distance to the target
	dist_to_target = norm(position - target_position)

	# Calculate the distance to the target in the previous step
	prev_dist_to_target = norm(previous_position - target_position)

	# Calculate the velocity towards the target
	vel_towards_target = dot(velocity, target_position - position)

	# Calculate the angle between the drone's heading and the direction to the target
	facing_dir = [cos(orientation[3]), sin(orientation[3])]
	drone_dir = [cos(orientation[1]) * cos(orientation[2]), sin(orientation[1]) * cos(orientation[2])]
	angle_to_target = acos(dot(facing_dir, drone_dir))

	# Calculate the angular velocity
	angular_vel_magnitude = norm(angular_velocity)

	# Calculate the reward based on various conditions
	reward = 0.0

	# Reward for getting closer to the target
	if dist_to_target < prev_dist_to_target
		reward += 0.1
	end
	if dist_to_target < 0.1
		reward += 1
	end

	# Reward for moving towards the target
	reward += 0.1 * (vel_towards_target > 0)

	# Penalize large distance to target
	reward -= 0.1 * dist_to_target

	# Penalize large angle to target
	reward -= 0.01 * angle_to_target

	# Penalize large angular velocity
	reward -= 0.001 * angular_vel_magnitude

	return reward
end

function is_terminated(env::DroneEnv)
	### Check if the drone orientation is too far from vertical
	roll = env.drone.orientation[1]
	pitch = env.drone.orientation[2]
	if abs(roll) > env.roll_threshold || abs(pitch) > env.pitch_threshold
		println("roll or pitch too large", " roll: ", roll, " pitch: ", pitch)
		env.done = true
	end

	if norm(env.drone.velocity) > env.velocity_threshold
		println("velocity too large")
		env.done = true
	end

	if norm(env.drone.angular_velocity) > env.angular_velocity_threshold
		println("angular velocity too large")
		env.done = true
	end

	if env.drone.position[3] < 0.0
		println("drone crashed")
		env.done = true
	end

	if norm([env.drone.position[1] - env.target_position[1]; env.drone.position[2] - env.target_position[2]; env.drone.position[3] - env.target_position[3]]) < 0.1
		println("drone reached target")		
		env.done = true
	end

	if env.time > env.max_time
		println("time limit reached")
		env.done = true
	end

	return env.done
end

function drone_dynamics!(du, u, p, t)
	rpms = p(t) # propeller speeds in RPM at time t
	
	### Get the mass, force_per_rpm, arm_length, and moment_of_inertia from the drone
	mass = u[13]
	force_per_rpm = u[14]
	arm_length = u[15]
	moment_of_inertia = u[16:25]


	### force generated by each propeller is squared to account for the fact that the force is proportional to the square of the propeller speed
	forces = [force_per_rpm*(rpms[1]^2), force_per_rpm*(rpms[2]^2), force_per_rpm*(rpms[3]^2), force_per_rpm*(rpms[4]^2)] # force generated by each propeller
	torques = [torque_per_rpm*(rpms[1]^2), torque_per_rpm*(rpms[2]^2), torque_per_rpm*(rpms[3]^2), torque_per_rpm*(rpms[4]^2)] # torque generated by each propeller

	net_torque_pitch = (forces[1] + forces[4] - forces[2] - forces[3])*arm_length # net torque around x-axis
	net_torque_roll = (forces[1] + forces[2] - forces[3] - forces[4])*arm_length # net torque around y-axis
	net_torque_yaw = (torques[1] + torques[3] - torques[2] - torques[4])

	total_force = sum(forces)

	# Consider the Pitch and Roll of the drone to determine the net force in the x and y directions
	tot_force_upward = total_force*cos(u[4])*cos(u[5]) # net force in the upward direction
	net_force_upward = tot_force_upward - mass*gravity # net force in the upward direction
	net_force_x = total_force*sin(u[4]) # net force in the x direction
	net_force_y = total_force*sin(u[5]) # net force in the y direction

	# println("net_force_x: ", net_force_x, " net_force_y: ", net_force_y, " net_force_upward: ", net_force_upward, " net_torque_roll: ", net_torque_roll, " net_torque_pitch: ", net_torque_pitch, " net_torque_yaw: ", net_torque_yaw)

	du[1] += u[4] # position updates with velocity
	du[2] += u[5] # position updates with velocity
	du[3] += u[6] # position updates with velocity
	
	du[4] = net_force_x / mass # x velocity update with acceleration
	du[5] = net_force_y / mass # y velocity update with acceleration
	du[6] = net_force_upward / mass # z velocity update with acceleration
	# if net_force_upward < 0
	#     println("net_force_upward: ", net_force_upward, " du[6]: ", du[6], " u[6]: ", u[6], " u[3]: ", u[3], " du[3]: ", du[3])
	#     # net_force_upward = 0
	# end

	

	# Check if drone is on the ground
	if du[3] < 0.0
		du[3] = 0.0
		du[6] = 0.0
	end

	# Check if drone is upside down
	if u[3] > pi/2 || u[3] < -pi/2
		du[4:6] = [0.0, 0.0, 0.0]
	end

	du[7:9] = u[10:12] # orientation updates with angular velocity
	du[10] = net_torque_pitch / moment_of_inertia[1] # pitch angular velocity update with angular acceleration
	du[11] = net_torque_roll / moment_of_inertia[2] # roll angular velocity update with angular acceleration
	du[12] = net_torque_yaw / moment_of_inertia[3] # yaw angular velocity update with angular acceleration
	# du[10] = net_torque_pitch / moment_of_inertia # pitch angular velocity update with angular acceleration
	# du[11] = net_torque_roll / moment_of_inertia # roll angular velocity update with angular acceleration
	# du[12] = net_torque_yaw / moment_of_inertia # yaw angular velocity update with angular acceleration
end

function drone_dynamicsV2!(u, rpms, t)
	### Copy the state vector to the derivative vector
	du = zeros(24)
	du[1:24] = u[1:24]

	### Get the mass, force_per_rpm, arm_length, and moment_of_inertia from the drone
	mass = u[13]
	force_per_rpm = u[14]
	arm_length = u[15]
	moment_of_inertia = u[16:24]
 
	### force generated by each propeller is squared to account for the fact that the force is proportional to the square of the propeller speed
	forces = [force_per_rpm*(rpms[1]^2), force_per_rpm*(rpms[2]^2), force_per_rpm*(rpms[3]^2), force_per_rpm*(rpms[4]^2)] # force generated by each propeller
	torques = [torque_per_rpm*(rpms[1]^2), torque_per_rpm*(rpms[2]^2), torque_per_rpm*(rpms[3]^2), torque_per_rpm*(rpms[4]^2)] # torque generated by each propeller

	net_torque_pitch = (-forces[1] + forces[2] + forces[3] - forces[4])*arm_length # net torque around x-axis
	net_torque_roll = (-forces[1] - forces[2] + forces[3] + forces[4])*arm_length # net torque around y-axis
	net_torque_yaw = (torques[1] + torques[3] - torques[2] - torques[4])
	# net_torque_yaw = (forces[1] + forces[3] - forces[2] - forces[4])*arm_length # net torque around z-axis



	total_force = sum(forces)

	# Consider the Pitch and Roll of the drone to determine the net force in the x and y directions
	tot_force_upward = total_force*cos(u[7])*cos(u[8]) # net force in the upward direction
	net_force_upward = tot_force_upward - mass*gravity # net force in the upward direction
	### Net force along the x and y directions are calculated by considering the orientation of the drone and the yaw angle
	net_force_x = total_force*sin(u[7])*cos(u[8]) # net force in the x direction
	net_force_y = total_force*cos(u[7])*sin(u[8]) # net force in the y direction



	du[1] += u[4] * t # position updates with velocity
	du[2] += u[5] * t # position updates with velocity
	du[3] += u[6] * t # position updates with velocity
	
	### Increse the velocity along the X and Y axes if the drone is atleast 5 cm above the ground
	if u[3] > 0.05
		du[4] += t * net_force_x / mass # x velocity update with acceleration
		du[5] += t * net_force_y / mass # y velocity update with acceleration

		du[7] += u[10] * t # orientation updates with angular velocity
		du[8] += u[11] * t # orientation updates with angular velocity

		du[10] = net_torque_roll / moment_of_inertia[1] # pitch angular velocity update with angular acceleration
		du[11] = net_torque_pitch / moment_of_inertia[5] # roll angular velocity update with angular acceleration	
	end
	du[6] += t * net_force_upward / mass # z velocity update with acceleration

	if du[3] <= 0.0
		du[1:3] = 0.0
		du[4:6] = 0.0
		# du[6] = 0.0
	end

	du[9] += u[12] * t # orientation updates with angular velocity
	du[12] = net_torque_yaw / moment_of_inertia[9] # yaw angular velocity update with angular acceleration
	# du[10] = net_torque_pitch / moment_of_inertia # pitch angular velocity update with angular acceleration
	# du[11] = net_torque_roll / moment_of_inertia # roll angular velocity update with angular acceleration
	# du[12] = net_torque_yaw / moment_of_inertia # yaw angular velocity update with angular acceleration

	return du
end

function get_state(drone::Drone)
	return [drone.position...; drone.velocity...; drone.orientation...; drone.angular_velocity...; drone.mass; drone.force_per_rpm; drone.arm_length; drone.moment_of_inertia...]
end

function step!(env::DroneEnv, action::Array{Float64, 1})
	tspan = 1 / frequency
	du = zeros(25)
	env.previous_position = env.drone.position
	du = drone_dynamicsV2!(get_state(env.drone), action, tspan)
	env.drone.position = du[1:3]
	env.drone.velocity = du[4:6]
	env.drone.orientation = du[7:9]
	env.drone.angular_velocity = du[10:12]
	env.reward = RewardFunction(env)
	env.time += tspan
	env.done = is_terminated(env)
	return env.reward, env.done
end