# import Pkg;
# Pkg.add("CUDA")
# Pkg.add("cuDNN")
# Pkg.add("CompilerPluginTools")
# Pkg.add("PlotlyJS")
# Pkg.add("DifferentialEquations")
# Pkg.add("Plots")
# Pkg.add("Flux")
# Pkg.add("JLD2")
# Pkg.add("BSON")
# Pkg.add("Distributions")
# Pkg.instantiate()

# using DifferentialEquations
using LinearAlgebra
using Distributions
using Plots
using Random
using Random
using Flux
using Flux.Optimise: update!
using CUDA
using BSON
using Base.Threads
import Base: rand
# using Zygote
# using Optimisers
# using Optimisers: setup, update!, Adam, ADAM
# using Zygote: gradient
using BSON: @load, @save

### Drone Paremeters
mass = 1.0
mass_arm = 0.050
mass_motor = 0.025
arm_length = 0.15

force_per_rpm = 4e-8 # force generated by each propeller per rpm, N/(rpm^2)
torque_per_rpm = arm_length * 1e-9 # torque generated by each propeller per rpm, Nm/(rpm^2)

I_arm = 1/3 * mass_arm * arm_length^2
I_motor = 1/2 * mass_motor * arm_length^2
Ixx = 2 * I_arm + 2 * I_motor
Iyy = 2 * I_arm + 2 * I_motor
Izz = 4 * I_arm + 4 * I_motor

gravity = 9.81 # gravitational constant, m/s^2
frequency = 1000 # frequency of the simulation, Hz

BOUND_MAX = 10.0

mutable struct Drone
	position::Array{Float64,1}
	velocity::Array{Float64,1}
	orientation::Array{Float64,1} # roll, pitch, yaw in radians
	angular_velocity::Array{Float64,1}
end

mutable struct DroneEnv
	drone::Drone
	target_position::Array{Float64,1}
	previous_position::Array{Float64,1}
	action::Array{Float64,1}
	reward::Float64
	done::Bool

	# boundaries::Array{Float64,2}
	bound_x::Float64
	bound_y::Float64
	bound_z::Float64
	# velocity_threshold::Float64
	# alititude_threshold::Float64
	# angular_velocity_threshold::Float64
	# roll_threshold::Float64
	# pitch_threshold::Float64

	time::Float64
	max_time::Float64
end

function DroneEnv()
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	target_position = [10.0, 10.0, 10.0]
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, 10)
	# DroneEnv(drone, target_position, previous_position, action, 0.0, false, 20, 1000, 5, pi/3, pi/3, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1})
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, 10)
end

function DroneEnv(target_position::Array{Float64,1}, max_time::Float64)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3))
	action = zeros(4)
	previous_position = zeros(3)
	DroneEnv(drone, target_position, previous_position, action, 0.0, false, BOUND_MAX, BOUND_MAX, BOUND_MAX, 0, max_time)
end

function reset!(env::DroneEnv)
	drone = Drone(zeros(3), zeros(3), zeros(3), zeros(3))
	env.action = zeros(4)
	env.previous_position = zeros(3)
	env.done = false
	env.reward = 0.0
	env.time = 0.0
	env.drone = drone
end

function RewardFunction(env::DroneEnv)
	orientation = env.drone.orientation
	dist_to_target = norm(env.target_position - env.drone.position)
	prev_dist_to_target = norm(env.previous_position - env.target_position)
	vel_towards_target = dot(env.drone.velocity, env.target_position - env.drone.position)

	velocity_magnitude = norm(env.drone.velocity)
	angular_vel_magnitude = norm(env.drone.angular_velocity)

	reward = 0.0

	if dist_to_target < prev_dist_to_target
		reward += 5
	else
		reward -= 5
	end

	reward -= 1e1 * abs(env.target_position[1] - env.drone.position[1]) / BOUND_MAX
	reward -= 1e1 * abs(env.target_position[2] - env.drone.position[2]) / BOUND_MAX
	reward -= 2e1 * abs(env.target_position[3] - env.drone.position[3]) / BOUND_MAX

	if dist_to_target < 0.5
		reward += 10
	end

	reward -= 2 * velocity_magnitude * (velocity_magnitude > 5)
	reward -= 2 * angular_vel_magnitude
	reward -= norm(orientation)

	if env.done
		if dist_to_target < 0.1
			reward += 100
		else
			reward -= 100
		end
	end

	return reward
end

function is_terminated(env::DroneEnv, verbose::Bool=false)
	if abs(env.drone.position[1]) > env.bound_x || abs(env.drone.position[2]) > env.bound_y || env.drone.position[3] < 0.0 || env.drone.position[3] > env.bound_z
		if verbose
			println("drone out of bounds")
		end
		env.done = true
	end

	# Check if the drone is crashed
	if env.drone.position[3] < 1e-5 && (abs(env.drone.orientation[1]) >= 0.99*pi || abs(env.drone.orientation[2]) >= 0.99*pi)
		if verbose
			println("drone crashed")
		end
		env.done = true
	end

	if norm([env.drone.position[1] - env.target_position[1]; env.drone.position[2] - env.target_position[2]; env.drone.position[3] - env.target_position[3]]) < 0.01
		if verbose
			println("drone reached target")
		end
		env.done = true
	end

	if env.time > env.max_time
		if verbose
			println("time limit reached")
		end
		env.done = true
	end


	return env.done
end

function get_angle_mod_2pi(angle)
	return atan(sin(angle), cos(angle))
end

function NonLinearDroneDynamics!(x::CuArray{Float32}, rpms, t)
	CUDA.allowscalar() do
		U = [
			force_per_rpm * (rpms[1]^2 + rpms[2]^2 + rpms[3]^2 + rpms[4]^2);
			force_per_rpm * (-rpms[1]^2 - rpms[2]^2 + rpms[3]^2 + rpms[4]^2);
			force_per_rpm * (-rpms[1]^2 + rpms[2]^2 + rpms[3]^2 - rpms[4]^2);
			torque_per_rpm * (-rpms[1]^2 + rpms[2]^2 - rpms[3]^2 + rpms[4]^2);
			-rpms[1] + rpms[2] - rpms[3] + rpms[4];
		] 

		u = [
			(sin(x[7]) * cos(x[9])) - (cos(x[7]) * sin(x[8]) * sin(x[9]));
			(cos(x[7]) * sin(x[8]) * cos(x[9])) + (sin(x[7]) * sin(x[9]));
			cos(x[7]) * cos(x[8]);
		]

		### Calculate the derivative of the state vector
		du = [
			x[1] + x[4]*t;
			x[2] + x[5]*t;
			x[3] + x[6]*t;
			x[4] + ((u[1] * U[1] / mass) * t);
			x[5] + ((u[2] * U[1] / mass) * t);
			x[6] + (((u[3] * U[1] / mass) - gravity) * t);

			get_angle_mod_2pi(x[7] + (x[10]*t));
			get_angle_mod_2pi(x[8] + (x[11]*t));
			get_angle_mod_2pi(x[9] + (x[12]*t));

			x[10] + ((
				(((Iyy - Izz) * x[11] * x[12]) + (U[2] * arm_length)) / Ixx
			) * t);
			x[11] + ((
				(((Izz - Ixx) * x[10] * x[12]) + (U[3] * arm_length)) / Iyy
			) * t);
			x[12] + ((
				(((Ixx - Iyy) * x[10] * x[11]) + (U[4])) / Izz
			) * t);
		]

		### Handle the case when the drone is on the ground and not enough thrust is applied to take off
		if du[3] <= 0.0
			du[3] = 0.0
			if du[6] < 0.0
				du[6] = 0.0
			end
		end
		return du
	end
end

function get_state(drone::Drone)
	return [drone.position...; drone.velocity...; drone.orientation...; drone.angular_velocity...;] |> gpu
end

function step!(env::DroneEnv, action::CuArray{Float64, 1}, verbose::Bool=false)
	tspan = 1 / frequency
	du = zeros(25)
	env.previous_position = env.drone.position
	env.action = action
	du = NonLinearDroneDynamics!(get_state(env.drone), action, tspan)
	env.drone.position = du[1:3]
	env.drone.velocity = du[4:6]
	env.drone.orientation = du[7:9]
	env.drone.angular_velocity = du[10:12]
	env.done = is_terminated(env, verbose)
	env.reward = RewardFunction(env)
	env.time += tspan
	return env.reward, env.done
end

function plotStateSpaces(state_spaces, dpi=500, save_fig=false)

	trajectory_x = []
	trajectory_y = []
	trajectory_z = []

	velocity_x = []
	velocity_y = []
	velocity_z = []

	orientation_x = []
	orientation_y = []
	orientation_z = []

	angular_velocity_x = []
	angular_velocity_y = []
	angular_velocity_z = []

	for state in state_spaces
		push!(trajectory_x, state[1])
		push!(trajectory_y, state[2])
		push!(trajectory_z, state[3])

		push!(velocity_x, state[4])
		push!(velocity_y, state[5])
		push!(velocity_z, state[6])

		push!(orientation_x, state[7])
		push!(orientation_y, state[8])
		push!(orientation_z, state[9])

		push!(angular_velocity_x, state[10])
		push!(angular_velocity_y, state[11])
		push!(angular_velocity_z, state[12])

	end

	image_size = (800, 600)
	### Plot the drone's position
	display(plot([trajectory_x, trajectory_y, trajectory_z], legend=:topleft, label=["x" "y" "z"], title="Trajectory", xlabel="Time (ms)", ylabel="Position (m)", lw=2, size=image_size, grid=true, dpi=dpi))
	# save the plot to a file
	if save_fig
		savefig("trajectory.png")
	end

	# ### Plot the drones velocity
	display(plot([velocity_x, velocity_y, velocity_z], legend=:topleft, label=["x" "y" "z"], title="Velocity", xlabel="Time (ms)", ylabel="Velocity (m/s)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("velocity.png")
	end

	# ### Plot the drones orientation
	display(plot([orientation_x, orientation_y, orientation_z], legend=:topleft, label=["x" "y" "z"], title="Orientation", xlabel="Time (ms)", ylabel="Orientation (rad)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("orientation.png")
	end

	# ### Plot the drones angular velocity
	display(plot([angular_velocity_x, angular_velocity_y, angular_velocity_z], legend=:topleft, label=["x" "y" "z"], title="Angular Velocity", xlabel="Time (ms)", ylabel="Angular Velocity (rad/s)", lw=2, size = image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("angular_velocity.png")
	end
end


function plotStateSpaces(state_spaces, dpi=100, save_fig=false, ouptut_dir="results", suffix="")

	trajectory_x = []
	trajectory_y = []
	trajectory_z = []

	velocity_x = []
	velocity_y = []
	velocity_z = []

	orientation_x = []
	orientation_y = []
	orientation_z = []

	angular_velocity_x = []
	angular_velocity_y = []
	angular_velocity_z = []

	for state in state_spaces
		push!(trajectory_x, state[1])
		push!(trajectory_y, state[2])
		push!(trajectory_z, state[3])

		push!(velocity_x, state[4])
		push!(velocity_y, state[5])
		push!(velocity_z, state[6])

		push!(orientation_x, state[7])
		push!(orientation_y, state[8])
		push!(orientation_z, state[9])

		push!(angular_velocity_x, state[10])
		push!(angular_velocity_y, state[11])
		push!(angular_velocity_z, state[12])
	end

	image_size = (800, 600)
	### Plot the drone's position
	display(plot([trajectory_x, trajectory_y, trajectory_z], legend=:topleft, label=["x" "y" "z"], title="Trajectory", xlabel="Time (ms)", ylabel="Position (m)", lw=2, size=image_size, grid=true, dpi=dpi))
	# save the plot to a file
	if save_fig
		savefig("$ouptut_dir/trajectory_$suffix.png")
	end

	# ### Plot the drones velocity
	display(plot([velocity_x, velocity_y, velocity_z], legend=:topleft, label=["x" "y" "z"], title="Velocity", xlabel="Time (ms)", ylabel="Velocity (m/s)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/velocity_$suffix.png")
	end

	# ### Plot the drones orientation
	display(plot([orientation_x, orientation_y, orientation_z], legend=:topleft, label=["x" "y" "z"], title="Orientation", xlabel="Time (ms)", ylabel="Orientation (rad)", lw=2, size=image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/orientation_$suffix.png")
	end

	# ### Plot the drones angular velocity
	display(plot([angular_velocity_x, angular_velocity_y, angular_velocity_z], legend=:topleft, label=["x" "y" "z"], title="Angular Velocity", xlabel="Time (ms)", ylabel="Angular Velocity (rad/s)", lw=2, size = image_size, grid=true, dpi=dpi))
	if save_fig
		savefig("$ouptut_dir/angular_velocity_$suffix.png")
	end
end

function plotMotorRpms(motor_rpms, dpi=100, save_fig=false, ouptut_dir="results", suffix="")
	motor1_rpms = []
	motor2_rpms = []
	motor3_rpms = []
	motor4_rpms = []

	for rpm in motor_rpms
		push!(motor1_rpms, rpm[1])
		push!(motor2_rpms, rpm[2])
		push!(motor3_rpms, rpm[3])
		push!(motor4_rpms, rpm[4])
	end

	display(
		plot(
			[motor1_rpms, motor2_rpms, motor3_rpms, motor4_rpms],
			legend=:topleft,
			label=["Motor 1" "Motor 2" "Motor 3" "Motor 4"], 
			xlabel="Time (ms)", 
			ylabel="RPM", 
			title="RPM of motors", 
			lw=2,
			size=(800, 600), 
			grid=true,
			dpi=dpi
		)
	)
	if save_fig
		savefig("$ouptut_dir/motor_rpms_$suffix.png")
	end
end